---
title: "The Microgame Decorator"
layout: base.njk
permalink: "microgame/"
---

<section class="decorator">
  <h2>{{ title }}</h2>
  <p>This is a simple tool to generate a cute little microgame cartridge form WarioWare: DIY for the Nintendo DS. It's one of my most beloved video games, and I needed this generator for a small project.</p>
  <div class="controls">
    <div class="option-group">
      <h2>Choose Base</h2>
      <div id="baseOptions" class="option-grid"></div>
      <label>Base Color:
        <input type="color" id="baseColor" value="#ffffff" />
      </label>
    </div>

    <div class="option-group">
      <h2>Choose Cover</h2>
      <div id="coverOptions" class="option-grid"></div>
      <label>Cover Color 1:
        <input type="color" id="coverColorAccent" value="#ff00ff" />
      </label>
      <label>Cover Color 2:
        <input type="color" id="coverColorBorder" value="#000000" />
      </label>
    </div>
  </div>

  <canvas id="preview" width="112" height="104"></canvas>
</section>

<style>
  .decorator .controls {
    display: flex;
    flex-wrap: wrap;
    gap: 2rem;
    justify-content: center;
  }

  .decorator .option-group {
    flex: 1 1 300px;
  }

  .decorator .option-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(48px, 1fr));
    gap: 0.5rem;
    margin-bottom: 1rem;
  }

  .decorator .option-grid label {
    display: inline-block;
    border: 2px solid transparent;
    border-radius: 6px;
    overflow: hidden;
    cursor: pointer;
    transition: border-color 0.2s;
  }

  .option-grid input[type="radio"]:checked + img {
    outline: 2px solid #0077ff;
  }

  .option-grid input {
    display: none;
  }

  .option-grid img {
    display: block;
    width: 100%;
    image-rendering: pixelated;
    background: #eee;
  }

  .decorator canvas {
    width: 224px; /* 2x upscaled from 112 */
    height: 208px; /* 2x upscaled from 104 */
    image-rendering: pixelated;
    border: 2px solid #aaa;
    display: block;
    margin: 2rem auto;
  }

  .decorator label {
    display: block;
    margin-top: 0.5rem;
    font-size: 0.9rem;
  }

  @media (max-width: 600px) {
    .decorator .controls {
      flex-direction: column;
      align-items: center;
    }
  }
</style>


<script type="module">
const baseList = Array.from({ length: 8 }, (_, i) => `base-${i + 1}.png`);
const coverList = Array.from({ length: 16 }, (_, i) => `cover-${i + 1}.png`);

const coverColorAccent = document.getElementById("coverColorAccent");
const coverColorBorder = document.getElementById("coverColorBorder");


const canvas = document.getElementById("preview");
const ctx = canvas.getContext("2d");
const IMAGE_SIZEX = 28;
const IMAGE_SIZEY = 26;

let selectedBase = baseList[0];
let selectedCover = coverList[0];

function createOptions(containerId, items, folder, groupName, onSelect) {
  const container = document.getElementById(containerId);
  items.forEach(filename => {
    const id = `${groupName}-${filename}`;

    const input = document.createElement("input");
    input.type = "radio";
    input.name = groupName;
    input.id = id;
    input.value = filename;
    if (filename === items[0]) input.checked = true;

    const img = document.createElement("img");
    img.src = `/images/microgame/${folder}/${filename}`;
    img.alt = filename;

    const label = document.createElement("label");
    label.htmlFor = id;
    label.appendChild(input);
    label.appendChild(img);

    input.addEventListener("change", () => onSelect(filename));

    container.appendChild(label);
  });
}

function loadImage(path) {
  return new Promise(resolve => {
    const img = new Image();
    img.src = path;
    img.onload = () => resolve(img);
  });
}

function hexToRgb(hex) {
  const bigint = parseInt(hex.slice(1), 16);
  return [(bigint >> 16) & 255, (bigint >> 8) & 255, bigint & 255];
}

function colorizeImage(img, color) {
  const offscreen = document.createElement("canvas");
  offscreen.width = IMAGE_SIZEX;
  offscreen.height = IMAGE_SIZEY;
  const ctx = offscreen.getContext("2d");

  ctx.drawImage(img, 0, 0);
  const imageData = ctx.getImageData(0, 0, IMAGE_SIZEX, IMAGE_SIZEY);
  const data = imageData.data;
  const [r, g, b] = hexToRgb(color);

  for (let i = 0; i < data.length; i += 4) {
    const a = data[i + 3];
    if (a > 0 && !(data[i] === 0 && data[i + 1] === 0 && data[i + 2] === 0)) {
      data[i] = r;
      data[i + 1] = g;
      data[i + 2] = b;
    }
  }

  ctx.putImageData(imageData, 0, 0);
  return offscreen;
}

function colorizeImageTwoTone(img, accentHex, borderHex) {
  const offscreen = document.createElement("canvas");
  offscreen.width = IMAGE_SIZEX;
  offscreen.height = IMAGE_SIZEY;
  const ctx = offscreen.getContext("2d");

  ctx.drawImage(img, 0, 0);
  const imageData = ctx.getImageData(0, 0, IMAGE_SIZEX, IMAGE_SIZEY);
  const data = imageData.data;

  const [ar, ag, ab] = hexToRgb(accentHex);
  const [br, bg, bb] = hexToRgb(borderHex);

  for (let i = 0; i < data.length; i += 4) {
    const r = data[i], g = data[i + 1], b = data[i + 2], a = data[i + 3];
    if (a === 0) continue;

    if (r === 255 && g === 255 && b === 255) {
      // White pixel: use border color
      data[i] = br;
      data[i + 1] = bg;
      data[i + 2] = bb;
    } else if (r === 0 && g === 0 && b === 0) {
      // Black pixel: make transparent
      data[i + 3] = 0;
    } else {
      // All others: use accent color
      data[i] = ar;
      data[i + 1] = ag;
      data[i + 2] = ab;
    }
  }

  ctx.putImageData(imageData, 0, 0);
  return offscreen;
}


const SCALE = 4;
const WIDTH = IMAGE_SIZEX;
const HEIGHT = IMAGE_SIZEY;

async function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  const basePath = `/images/microgame/base/${selectedBase}`;
  const coverPath = `/images/microgame/cover/${selectedCover}`;

  const [baseImg, coverImg] = await Promise.all([
    loadImage(basePath),
    loadImage(coverPath)
  ]);

  const baseLayer = colorizeImage(baseImg, baseColor.value);
  const coverLayer = colorizeImageTwoTone(
    coverImg,
    coverColorAccent.value,
    coverColorBorder.value
  );

  ctx.imageSmoothingEnabled = false; // <- Important to preserve pixel sharpness

  // Draw scaled base
  ctx.drawImage(baseLayer, 0, 0, WIDTH, HEIGHT, 0, 0, WIDTH * SCALE, HEIGHT * SCALE);
  // Draw scaled cover
  ctx.drawImage(coverLayer, 0, 0, WIDTH, HEIGHT, 0, 0, WIDTH * SCALE, HEIGHT * SCALE);
}



createOptions("baseOptions", baseList, "base", "base", name => {
  selectedBase = name;
  draw();
});
createOptions("coverOptions", coverList, "cover", "cover", name => {
  selectedCover = name;
  draw();
});

[baseColor, coverColorAccent, coverColorBorder].forEach(input =>
  input.addEventListener("change", draw)
);


draw();

</script>
